<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HTML路CSS路JS on Jason Duong</title>
    <link>https://michaelneuper.github.io/hugo-texify3/tags/htmlcssjs/</link>
    <description>Recent content in HTML路CSS路JS on Jason Duong</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>duongjason11@gmail.com (Jason Duong)</managingEditor>
    <webMaster>duongjason11@gmail.com (Jason Duong)</webMaster>
    <lastBuildDate>Mon, 02 Feb 2026 14:05:57 -0800</lastBuildDate>
    <atom:link href="https://michaelneuper.github.io/hugo-texify3/tags/htmlcssjs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>An Algorithm Vizualizer</title>
      <link>https://michaelneuper.github.io/hugo-texify3/posts/algorithm-vizualizer-project/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate><author>duongjason11@gmail.com (Jason Duong)</author>
      <guid>https://michaelneuper.github.io/hugo-texify3/posts/algorithm-vizualizer-project/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/duong-jason/binary-bros&#34;&gt;Link to Source Code&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;figma-design-prototypes&#34;&gt;Figma Design Prototypes&lt;/h2&gt;&#xA;&lt;iframe style=&#34;border: 1px solid rgba(0, 0, 0, 0.1);&#34; width=&#34;800&#34; height=&#34;450&#34; src=&#34;https://www.figma.com/embed?embed_host=share&amp;url=https%3A%2F%2Fwww.figma.com%2Ffile%2FqihsKn3iY99zQqTtMatn8Z%2FLanding-Page%3Ftype%3Ddesign%26node-id%3D0%253A1%26mode%3Ddesign%26t%3DsFSbak2BwHFp1aCv-1&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xD;&#xA;&lt;h2 id=&#34;user-stories-and-burndown-chart&#34;&gt;User Stories and Burndown Chart&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/spreadsheets/d/e/2PACX-1vSezwps9xOk-6Rl4cwyeZoJpvOKecQbakP0JX81jdKlUagxcm1o8KkY7ZCbAMgxGEtCDveL_jR8fIJe/pubhtml&#34;&gt;Link to Google Sheets&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;stand-up-meetings-and-retrospectives&#34;&gt;Stand Up Meetings and Retrospectives&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/e/2PACX-1vRfUL42RWWhExU_IpmiscmZg4CCbbjoyhtOksWm0N43jliuOSuNtscRxw2rztDo3DzcLAs7UOS1FAfC/pub&#34;&gt;Link to Google Docs&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Larks Ant</title>
      <link>https://michaelneuper.github.io/hugo-texify3/posts/larks-ant-project/</link>
      <pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><author>duongjason11@gmail.com (Jason Duong)</author>
      <guid>https://michaelneuper.github.io/hugo-texify3/posts/larks-ant-project/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/jasonduong11/CPSC-335/tree/main/Project%201&#34;&gt;Link to Source Code&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;online-demo&#34;&gt;Online Demo&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;&#xA;&lt;p&gt;$q$ = &lt;output id=&#34;qt&#34;&gt;&lt;/output&gt;&lt;br&gt;&#xA;$T_{ij}$ = &lt;output id=&#34;tij&#34;&gt;&lt;/output&gt;&lt;br&gt;&#xA;$\theta$ = &lt;output id=&#34;theta&#34;&gt;&lt;/output&gt;&lt;br&gt;&#xA;$\text{counter}$ = &lt;output id=&#34;counter&#34;&gt;&lt;/output&gt;&lt;/p&gt;&#xA;&lt;figure&gt;&#xD;&#xA;    &lt;canvas width=&#34;800&#34; height=&#34;400&#34; id=&#34;game&#34;&gt;&lt;/canvas&gt;&lt;br&gt;&#xD;&#xA;    &lt;figurecaption&gt;Fig. 1: Larks Ant Demo&lt;/figurecaption&gt;&#xD;&#xA;&lt;/figure&gt;&#xD;&#xA;&lt;script type=&#34;text/javascript&#34;&gt;&#xD;&#xA;var canvas = document.getElementById(&#34;game&#34;);&#xD;&#xA;var context = canvas.getContext(&#34;2d&#34;);&#xD;&#xA;context.strokeStyle = &#34;black&#34;;&#xD;&#xA;var count = 0;&#xD;&#xA;&#xD;&#xA;var qt = document.getElementById(&#34;qt&#34;);&#xD;&#xA;var tij = document.getElementById(&#34;tij&#34;);&#xD;&#xA;var theta = document.getElementById(&#34;theta&#34;);&#xD;&#xA;var c = document.getElementById(&#34;counter&#34;);&#xD;&#xA;&#xD;&#xA;const r_states = [&#34;Normal&#34;, &#34;Countdown&#34;];&#xD;&#xA;const r_colors = [&#34;Black&#34;, &#34;Blue&#34;, &#34;Yellow&#34;, &#34;Red&#34;];&#xD;&#xA;const colors = [&#34;#000000&#34;, &#34;#89CFF0&#34;, &#34;#FFF300&#34;, &#34;#FF6347&#34;];&#xD;&#xA;const nose = [&#34;N&#34;, &#34;W&#34;, &#34;S&#34;, &#34;E&#34;];&#xD;&#xA;const action = [0, 1, 2, 1];&#xD;&#xA;&#xD;&#xA;class Board {&#xD;&#xA;  constructor(cell, width, height) {&#xD;&#xA;    this.cell = cell;&#xD;&#xA;    this.width = width;&#xD;&#xA;    this.height = height;&#xD;&#xA;    this.pixel = new Map();&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  increment_color() {&#xD;&#xA;    let pos = &#34;@&#34; + ant.x + ant.y;&#xD;&#xA;    if (this.pixel.has(pos)) {&#xD;&#xA;      this.pixel.set(pos, (board.pixel.get(pos) + 1) % 4);&#xD;&#xA;    } else {&#xD;&#xA;      this.pixel.set(pos, 1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    context.fillStyle = colors[board.pixel.get(pos)];&#xD;&#xA;    context.strokeRect(ant.x, ant.y, this.cell, this.cell);&#xD;&#xA;    context.fillRect(ant.x, ant.y, this.cell, this.cell);&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  get_color(pos) {&#xD;&#xA;    return board.pixel.has(pos) ? board.pixel.get(pos) : 0;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;class Ant {&#xD;&#xA;  constructor(x, y, state, nose, counter) {&#xD;&#xA;    this.x = x;&#xD;&#xA;    this.y = y;&#xD;&#xA;    this.state = state;&#xD;&#xA;    this.nose = nose;&#xD;&#xA;    this.counter = counter;&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  fsm(action) {&#xD;&#xA;    let transition;&#xD;&#xA;    this.counter = board.get_color(&#34;@&#34; + ant.x + ant.y);&#xD;&#xA;&#xD;&#xA;    if (this.state == 0) {&#xD;&#xA;      if (action == 0) {&#xD;&#xA;        theta.innerHTML = &#34;Left&#34;;&#xD;&#xA;        ant.nose = ++ant.nose % 4;&#xD;&#xA;      }&#xD;&#xA;      else if (action == 1) {&#xD;&#xA;        theta.innerHTML = &#34;Right&#34;;&#xD;&#xA;        if (ant.nose == 0)&#xD;&#xA;          ant.nose = 3;&#xD;&#xA;        else&#xD;&#xA;          ant.nose--;&#xD;&#xA;      }&#xD;&#xA;      else {&#xD;&#xA;        theta.innerHTML = &#34;Straight&#34;;&#xD;&#xA;        this.state = 1;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;      if (this.counter &lt;= 0) {&#xD;&#xA;        this.state = 0;&#xD;&#xA;      } else {&#xD;&#xA;        this.counter--;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;  move() {&#xD;&#xA;    let dx = this.x;&#xD;&#xA;    let dy = this.y;&#xD;&#xA;    let size = board.cell;&#xD;&#xA;    let max_width = board.width * size;&#xD;&#xA;    let max_height = board.height * size;&#xD;&#xA;&#xD;&#xA;    switch (nose[ant.nose]) {&#xD;&#xA;      case &#34;N&#34;: {&#xD;&#xA;        dy = (dy == 0 ? max_height : dy) - size;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      case &#34;W&#34;: {&#xD;&#xA;        dx = (dx == 0 ? max_width : dx) - size;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      case &#34;S&#34;: {&#xD;&#xA;        dy = (dy + size) % max_height;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      case &#34;E&#34;: {&#xD;&#xA;        dx = (dx + size) % max_width;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    this.x = dx; // move ant in x-dir&#xD;&#xA;    this.y = dy; // move ant in y-dir&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;const board = new Board(10, 80, 40);&#xD;&#xA;const ant = new Ant(400, 200, 0, 0, 0);&#xD;&#xA;&#xD;&#xA;var halt = false;&#xD;&#xA;var speed = 60;&#xD;&#xA;&#xD;&#xA;function update() {&#xD;&#xA;  qt.innerHTML = r_states[ant.state];&#xD;&#xA;  tij.innerHTML = r_colors[board.get_color(&#34;@&#34; + ant.x + ant.y)];&#xD;&#xA;  c.innerHTML = ant.counter;&#xD;&#xA;  ant.fsm(action[board.get_color(&#34;@&#34; + ant.x + ant.y)]);&#xD;&#xA;  board.increment_color();&#xD;&#xA;  ant.move();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;function loop() {&#xD;&#xA;  requestAnimationFrame(loop);&#xD;&#xA;  if (++count &lt; speed) return;&#xD;&#xA;  if (!halt) {&#xD;&#xA;    update();&#xD;&#xA;  }&#xD;&#xA;  count = 0;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;document.addEventListener(&#34;keydown&#34;, (e) =&gt; {&#xD;&#xA;  switch (e.which) {&#xD;&#xA;    case 72:&#xD;&#xA;      halt = !halt;&#xD;&#xA;      break;&#xD;&#xA;    case 65:&#xD;&#xA;      speed = Math.max(1, speed - 10);&#xD;&#xA;      break;&#xD;&#xA;    case 68:&#xD;&#xA;      speed = Math.min(60, speed + 10);&#xD;&#xA;      break;&#xD;&#xA;  }&#xD;&#xA;});&#xD;&#xA;&#xD;&#xA;requestAnimationFrame(loop);&#xD;&#xA;&lt;/script&gt;&#xD;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;div class=&#34;definition&#34;&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;Definition 1&lt;/strong&gt;: &lt;em&gt;Larks Ant&lt;/em&gt; is a 2D cellular automaton $\mathcal{A}$ that consists of a pair set of states $\mathbf{Q}$, a quadruple of colors $\Sigma$, an initial state $q_0\in\mathbf{Q}$, a local variable $\text{counter}$, and a transition function $\delta_\mathcal{A}:\mathbf{Q}\times\Sigma\to\mathbf{Q}\times\Sigma\times\theta$ where&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
